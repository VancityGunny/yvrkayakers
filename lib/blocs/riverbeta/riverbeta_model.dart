import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:equatable/equatable.dart';
import 'package:geoflutterfire/geoflutterfire.dart';
import 'package:yvrkayakers/blocs/user/user_model.dart';
import 'package:yvrkayakers/common/common_functions.dart';

/// generate by https://javiercbk.github.io/json_to_dart/
class AutogeneratedRiverbeta {
  final List<RiverbetaModel> results;

  AutogeneratedRiverbeta({this.results});

  factory AutogeneratedRiverbeta.fromJson(Map<String, dynamic> json) {
    List<RiverbetaModel> temp;
    if (json['results'] != null) {
      temp = <RiverbetaModel>[];
      json['results'].forEach((v) {
        temp.add(RiverbetaModel.fromJson(v as Map<String, dynamic>));
      });
    }
    return AutogeneratedRiverbeta(results: temp);
  }

  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    if (results != null) {
      data['results'] = results.map((v) => v.toJson()).toList();
    }
    return data;
  }
}

class RiverbetaShortModel extends Equatable {
  final String id;
  final String riverName;
  final String sectionName;
  final double difficulty; // 2.75 for grade III- and 3.25 for grade III+
  final double minFlow; // minimum runnable flow in cms
  final double maxFlow; // maximum runnable flow in cms
  final String gaugeUnit;
  final String country;

  String riverHashtag() {
    return CommonFunctions.getHashtag(river: this);
  }

  RiverbetaShortModel(
      this.id,
      this.riverName,
      this.sectionName,
      this.difficulty,
      this.minFlow,
      this.maxFlow,
      this.gaugeUnit,
      this.country);
  @override
  List<Object> get props => [
        id,
        riverName,
        sectionName,
        difficulty,
        minFlow,
        maxFlow,
        gaugeUnit,
        country
      ];

  factory RiverbetaShortModel.fromFire(DocumentSnapshot doc) {
    var json = doc.data();
    return RiverbetaShortModel(
        doc.id,
        json['riverName'] as String,
        json['sectionName'] as String,
        json['difficulty'] as double,
        json['minFlow'] as double,
        json['maxFlow'] as double,
        json['gaugeUnit'] as String,
        (json['country'] == null) ? null : json['country'] as String);
  }
  factory RiverbetaShortModel.fromJson(Map<String, dynamic> json) {
    return RiverbetaShortModel(
        null,
        json['riverName'] as String,
        json['sectionName'] as String,
        json['difficulty'] as double,
        json['minFlow'] as double,
        json['maxFlow'] as double,
        json['gaugeUnit'] as String,
        (json['country'] == null) ? null : json['country'] as String);
  }
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    data['id'] = id;
    data['riverName'] = riverName;
    data['sectionName'] = sectionName;
    data['difficulty'] = difficulty;
    data['minFlow'] = minFlow;
    data['maxFlow'] = maxFlow;
    data['gaugeUnit'] = gaugeUnit;
    data['country'] = country;
    return data;
  }
}

class RiverbetaModel extends RiverbetaShortModel {
  final GeoFirePoint putInLocation;
  final GeoFirePoint takeOutLocation;
  final String province;

  final double flowIncrement; // incremental for the gauge

  RiverbetaModel(
      id,
      riverName,
      sectionName,
      difficulty,
      this.putInLocation,
      this.takeOutLocation,
      minFlow,
      maxFlow,
      gaugeUnit,
      this.flowIncrement,
      this.province,
      country)
      : super(id, riverName, sectionName, difficulty, minFlow, maxFlow,
            gaugeUnit, country);

  @override
  List<Object> get props => [
        id,
        riverName,
        sectionName,
        difficulty,
        putInLocation,
        takeOutLocation,
        minFlow,
        maxFlow,
        gaugeUnit,
        flowIncrement,
        province,
        country
      ];

  factory RiverbetaModel.fromFire(DocumentSnapshot doc) {
    var json = doc.data();
    return RiverbetaModel(
        doc.id,
        json['riverName'] as String,
        json['sectionName'] as String,
        double.parse(json['difficulty'].toString()),
        (json['putInLocation'] == null)
            ? null
            : GeoFirePoint(json['putInLocation']['geopoint'].latitude,
                json['putInLocation']['geopoint'].longitude),
        (json['takeOutLocation'] == null)
            ? null
            : GeoFirePoint(json['takeOutLocation']['geopoint'].latitude,
                json['takeOutLocation']['geopoint'].longitude),
        json['minFlow'] as double,
        json['maxFlow'] as double,
        json['gaugeUnit'] as String,
        json['flowIncrement'] as double,
        (json['province'] == null) ? null : json['province'] as String,
        (json['country'] == null) ? null : json['country'] as String);
  }

  factory RiverbetaModel.fromJson(Map<String, dynamic> json) {
    return RiverbetaModel(
        json['id'] as String,
        json['riverName'] as String,
        json['sectionName'] as String,
        json['difficulty'] as double,
        (json['putInLocation'] == null)
            ? null
            : GeoFirePoint(json['putInLocation']['geopoint'].latitude,
                json['putInLocation']['geopoint'].longitude),
        (json['takeOutLocation'] == null)
            ? null
            : GeoFirePoint(json['takeOutLocation']['geopoint'].latitude,
                json['takeOutLocation']['geopoint'].longitude),
        json['minFlow'] as double,
        json['maxFlow'] as double,
        json['gaugeUnit'] as String,
        json['flowIncrement'] as double,
        (json['province'] == null) ? null : json['province'] as String,
        (json['country'] == null) ? null : json['country'] as String);
  }

  RiverbetaShortModel getRiverbetaShort() {
    return RiverbetaShortModel(id, riverName, sectionName, difficulty, minFlow,
        maxFlow, gaugeUnit, country);
  }

  @override
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    //data['id'] = id;
    data['riverName'] = riverName;
    data['sectionName'] = sectionName;
    data['difficulty'] = difficulty;
    data['putInLocation'] = (putInLocation == null) ? null : putInLocation.data;
    data['takeOutLocation'] =
        (takeOutLocation == null) ? null : takeOutLocation.data;
    data['minFlow'] = minFlow;
    data['maxFlow'] = maxFlow;
    data['gaugeUnit'] = gaugeUnit;
    data['levelIncrement'] = flowIncrement;
    data['province'] = province;
    data['country'] = country;
    return data;
  }

  Map<String, dynamic> toJsonIncludeId() {
    final data = <String, dynamic>{};
    data['id'] = id;
    data['riverName'] = riverName;
    data['sectionName'] = sectionName;
    data['difficulty'] = difficulty;
    data['putInLocation'] = (putInLocation == null) ? null : putInLocation.data;
    data['takeOutLocation'] =
        (takeOutLocation == null) ? null : takeOutLocation.data;
    data['minFlow'] = minFlow;
    data['maxFlow'] = maxFlow;
    data['gaugeUnit'] = gaugeUnit;
    data['levelIncrement'] = flowIncrement;
    data['province'] = province;
    data['country'] = country;
    return data;
  }
}

class RiverAnnualStatModel extends Equatable {
  List<RiverStatUserEntry> entries;
  List<UserShortModel> visitors; // collection of short usermodel

  RiverAnnualStatModel(this.entries, this.visitors);
  @override
  // TODO: implement props
  List<Object> get props => [entries, visitors];

  factory RiverAnnualStatModel.fromJson(Map<String, dynamic> json) {
    List<RiverStatUserEntry> tempEntries = new List<RiverStatUserEntry>();
    List<UserShortModel> tempVisitors = new List<UserShortModel>();
    json['entries'].forEach((v) {
      tempEntries.add(RiverStatUserEntry.fromJson(v as Map<String, dynamic>));
    });
    json['visitors'].forEach((v) {
      tempVisitors.add(UserShortModel.fromJson(v as Map<String, dynamic>));
    });
    return RiverAnnualStatModel(tempEntries, tempVisitors);
  }
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    data['entries'] = entries.map((e) => e.toJson()).toList();
    data['visitors'] = visitors.map((e) => e.toJson()).toList();
    return data;
  }
}

class RiverStatUserEntry extends Equatable {
  final String uid;
  final DateTime logDate;
  final String userRiverlogId;
  final int sequenceNumber; // arbitary sequence just so we can identify log run

  RiverStatUserEntry(
      this.uid, this.logDate, this.userRiverlogId, this.sequenceNumber);
  @override
  // TODO: implement props
  List<Object> get props => [uid, logDate, userRiverlogId];
  factory RiverStatUserEntry.fromJson(Map<String, dynamic> json) {
    return RiverStatUserEntry(
        json['userId'] as String,
        json['logDate'].toDate(),
        json['userRiverlogId'] as String,
        (json['sequenceNumber'] == null) ? 0 : json['sequenceNumber'] as int);
  }
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    data['userId'] = uid;
    data['logDate'] = logDate;
    data['userRiverlogId'] = userRiverlogId;
    data['sequenceNumber'] = sequenceNumber;
    return data;
  }
}
