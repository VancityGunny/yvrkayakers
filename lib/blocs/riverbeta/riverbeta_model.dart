import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:equatable/equatable.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:geoflutterfire/geoflutterfire.dart';
import 'package:yvrkayakers/blocs/user/user_model.dart';

/// generate by https://javiercbk.github.io/json_to_dart/
class AutogeneratedRiverbeta {
  final List<RiverbetaModel> results;

  AutogeneratedRiverbeta({this.results});

  factory AutogeneratedRiverbeta.fromJson(Map<String, dynamic> json) {
    List<RiverbetaModel> temp;
    if (json['results'] != null) {
      temp = <RiverbetaModel>[];
      json['results'].forEach((v) {
        temp.add(RiverbetaModel.fromJson(v as Map<String, dynamic>));
      });
    }
    return AutogeneratedRiverbeta(results: temp);
  }

  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    if (results != null) {
      data['results'] = results.map((v) => v.toJson()).toList();
    }
    return data;
  }
}

class RiverbetaShortModel extends Equatable {
  final String id;
  final String riverName;
  final String sectionName;
  final double difficulty; // 2.75 for grade III- and 3.25 for grade III+

  String riverHashtag() {
    return "YKR_" + riverName.replaceAll(" ", "");
  }

  RiverbetaShortModel(
      this.id, this.riverName, this.sectionName, this.difficulty);
  @override
  List<Object> get props => [id, riverName, sectionName, difficulty];

  factory RiverbetaShortModel.fromFire(DocumentSnapshot doc) {
    var json = doc.data();
    return RiverbetaShortModel(doc.id, json['riverName'] as String,
        json['sectionName'] as String, json['difficulty'] as double);
  }
  factory RiverbetaShortModel.fromJson(Map<String, dynamic> json) {
    return RiverbetaShortModel(null, json['riverName'] as String,
        json['sectionName'] as String, json['difficulty'] as double);
  }
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    data['id'] = id;
    data['riverName'] = riverName;
    data['sectionName'] = sectionName;
    data['difficulty'] = difficulty;
    return data;
  }
}

class ExtObjectLink extends Equatable {
  final String thumbnail;
  final String caption;
  final String url;
  ExtObjectLink(this.thumbnail, this.caption, this.url);
  @override
  // TODO: implement props
  List<Object> get props => [thumbnail, caption, url];

  factory ExtObjectLink.fromJson(Map<String, dynamic> json) {
    return ExtObjectLink(
        json['thumbnail'] as String, json['caption'], json['url'] as String);
  }
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    data['thumbnail'] = thumbnail;
    data['caption'] = caption;
    data['url'] = url;
    return data;
  }
}

class RiverbetaModel extends RiverbetaShortModel {
  final GeoFirePoint putInLocation;
  final GeoFirePoint takeOutLocation;
  final double minFlow; // minimum runnable flow in cms
  final double maxFlow; // maximum runnable flow in cms
  final String gaugeUnit;

  final double flowIncrement; // incremental for the gauge
  List<ExtObjectLink> relatedVideos;
  final DateTime lastFetchVideos;

  RiverbetaModel(
      id,
      riverName,
      sectionName,
      difficulty,
      this.putInLocation,
      this.takeOutLocation,
      this.minFlow,
      this.maxFlow,
      this.gaugeUnit,
      this.flowIncrement,
      this.relatedVideos,
      this.lastFetchVideos)
      : super(id, riverName, sectionName, difficulty);

  @override
  List<Object> get props => [
        id,
        riverName,
        sectionName,
        difficulty,
        putInLocation,
        takeOutLocation,
        minFlow,
        maxFlow,
        gaugeUnit,
        flowIncrement,
        relatedVideos,
        lastFetchVideos
      ];

  factory RiverbetaModel.fromFire(DocumentSnapshot doc) {
    var json = doc.data();
    return RiverbetaModel(
        doc.id,
        json['riverName'] as String,
        json['sectionName'] as String,
        double.parse(json['difficulty'].toString()),
        (json['putInLocation'] == null)
            ? null
            : GeoFirePoint(json['putInLocation']['geopoint'].latitude,
                json['putInLocation']['geopoint'].longitude),
        (json['takeOutLocation'] == null)
            ? null
            : GeoFirePoint(json['takeOutLocation']['geopoint'].latitude,
                json['takeOutLocation']['geopoint'].longitude),
        json['minFlow'] as double,
        json['maxFlow'] as double,
        json['gaugeUnit'] as String,
        json['flowIncrement'] as double,
        (json['relatedVideos'] == null)
            ? List<ExtObjectLink>()
            : json['relatedVideos']
                .map<ExtObjectLink>((e) => ExtObjectLink.fromJson(e))
                .toList(),
        (json['lastFetchVideos'] == null)
            ? null
            : json['lastFetchVideos'].toDate());
  }

  factory RiverbetaModel.fromJson(Map<String, dynamic> json) {
    return RiverbetaModel(
        json['id'] as String,
        json['riverName'] as String,
        json['sectionName'] as String,
        json['difficulty'] as double,
        (json['putInLocation'] == null)
            ? null
            : GeoFirePoint(json['putInLocation']['geopoint'].latitude,
                json['putInLocation']['geopoint'].longitude),
        (json['takeOutLocation'] == null)
            ? null
            : GeoFirePoint(json['takeOutLocation']['geopoint'].latitude,
                json['takeOutLocation']['geopoint'].longitude),
        json['minFlow'] as double,
        json['maxFlow'] as double,
        json['gaugeUnit'] as String,
        json['flowIncrement'] as double,
        (json['relatedVideos'] == null)
            ? List<ExtObjectLink>()
            : json['relatedVideos']
                .map<ExtObjectLink>((e) => ExtObjectLink.fromJson(e))
                .toList(),
        (json['lastFetchVideos'] == null)
            ? null
            : json['lastFetchVideos'].toDate());
  }

  RiverbetaShortModel getRiverbetaShort() {
    return RiverbetaShortModel(id, riverName, sectionName, difficulty);
  }

  @override
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    //data['id'] = id;
    data['riverName'] = riverName;
    data['sectionName'] = sectionName;
    data['difficulty'] = difficulty;
    data['putInLocation'] = (putInLocation == null) ? null : putInLocation.data;
    data['takeOutLocation'] =
        (takeOutLocation == null) ? null : takeOutLocation.data;
    data['minFlow'] = minFlow;
    data['maxFlow'] = maxFlow;
    data['gaugeUnit'] = gaugeUnit;
    data['levelIncrement'] = flowIncrement;
    data['relatedVideos'] = relatedVideos.map((e) => e.toJson()).toList();
    data['lastFetchVideos'] = lastFetchVideos;
    return data;
  }

  Map<String, dynamic> toJsonIncludeId() {
    final data = <String, dynamic>{};
    data['id'] = id;
    data['riverName'] = riverName;
    data['sectionName'] = sectionName;
    data['difficulty'] = difficulty;
    data['putInLocation'] = (putInLocation == null) ? null : putInLocation.data;
    data['takeOutLocation'] =
        (takeOutLocation == null) ? null : takeOutLocation.data;
    data['minFlow'] = minFlow;
    data['maxFlow'] = maxFlow;
    data['gaugeUnit'] = gaugeUnit;
    data['levelIncrement'] = flowIncrement;
    data['relatedVideos'] = relatedVideos.map((e) => e.toJson()).toList();
    data['lastFetchVideos'] = lastFetchVideos;
    return data;
  }
}

class RiverAnnualStatModel extends Equatable {
  List<RiverStatUserEntry> entries;
  List<UserShortModel> visitors; // collection of short usermodel

  RiverAnnualStatModel(this.entries, this.visitors);
  @override
  // TODO: implement props
  List<Object> get props => [entries, visitors];

  factory RiverAnnualStatModel.fromJson(Map<String, dynamic> json) {
    List<RiverStatUserEntry> tempEntries = new List<RiverStatUserEntry>();
    List<UserShortModel> tempVisitors = new List<UserShortModel>();
    json['entries'].forEach((v) {
      tempEntries.add(RiverStatUserEntry.fromJson(v as Map<String, dynamic>));
    });
    json['visitors'].forEach((v) {
      tempVisitors.add(UserShortModel.fromJson(v as Map<String, dynamic>));
    });
    return RiverAnnualStatModel(tempEntries, tempVisitors);
  }
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    data['entries'] = entries.map((e) => e.toJson()).toList();
    data['visitors'] = visitors.map((e) => e.toJson()).toList();
    return data;
  }
}

class RiverStatUserEntry extends Equatable {
  final String userId;
  final DateTime logDate;
  final String userRiverlogId;
  final int sequenceNumber; // arbitary sequence just so we can identify log run

  RiverStatUserEntry(
      this.userId, this.logDate, this.userRiverlogId, this.sequenceNumber);
  @override
  // TODO: implement props
  List<Object> get props => [userId, logDate, userRiverlogId];
  factory RiverStatUserEntry.fromJson(Map<String, dynamic> json) {
    return RiverStatUserEntry(
        json['userId'] as String,
        json['logDate'].toDate(),
        json['userRiverlogId'] as String,
        (json['sequenceNumber'] == null) ? 0 : json['sequenceNumber'] as int);
  }
  Map<String, dynamic> toJson() {
    final data = <String, dynamic>{};
    data['userId'] = userId;
    data['logDate'] = logDate;
    data['userRiverlogId'] = userRiverlogId;
    data['sequenceNumber'] = sequenceNumber;
    return data;
  }
}
